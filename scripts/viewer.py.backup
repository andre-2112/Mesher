#!/usr/bin/env python3
"""
Interactive Dual-Pane Mesh Viewer
Displays point cloud and mesh side-by-side with dropdown controls
for selecting meshing methods and export formats.
"""

import open3d as o3d
import open3d.visualization.gui as gui
import open3d.visualization.rendering as rendering
import numpy as np
import argparse
import sys
from pathlib import Path


class DualPaneMeshViewer:
    """Interactive viewer with side-by-side point cloud and mesh display."""
    
    def __init__(self, input_file, mesh_dir="meshes"):
        self.input_file = input_file
        self.mesh_dir = Path(mesh_dir)
        
        # Load point cloud
        self.point_cloud = self._load_point_cloud()
        
        # Available options
        self.methods = ["poisson", "bpa", "alpha"]
        self.formats = ["obj", "glb", "stl"]
        
        # Current selections
        self.current_method = "poisson"
        self.current_format = "obj"
        
        # Current mesh
        self.current_mesh = None
        
        # Initialize GUI
        self.app = gui.Application.instance
        self.app.initialize()
        
        self.window = self.app.create_window("Mesh Viewer - Point Cloud & Mesh Comparison", 1600, 800)
        self._setup_ui()
        
    def _load_point_cloud(self):
        """Load the point cloud from file."""
        try:
            pcd = o3d.io.read_point_cloud(self.input_file)
            if not pcd.has_points():
                raise ValueError("Point cloud is empty")
            
            # Ensure normals are present
            if not pcd.has_normals():
                pcd.estimate_normals(
                    search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)
                )
            
            # Report color status
            if pcd.has_colors():
                print(f"Point cloud has vertex colors")
            else:
                print(f"Warning: Point cloud has no vertex colors")
            
            print(f"Loaded point cloud with {len(pcd.points)} points")
            return pcd
            
        except Exception as e:
            print(f"Error loading point cloud: {e}")
            sys.exit(1)
    
    def _load_mesh(self, method, format_type):
        """Load a mesh based on method and format."""
        # Extract base name from input file (e.g., "chiller" from "chiller.ply")
        input_base = Path(self.input_file).stem
        mesh_filename = f"{input_base}_{method}.{format_type}"
        mesh_path = self.mesh_dir / mesh_filename
        
        if not mesh_path.exists():
            print(f"Warning: Mesh file not found: {mesh_path}")
            return None
        
        try:
            mesh = o3d.io.read_triangle_mesh(str(mesh_path))
            
            if len(mesh.triangles) == 0:
                print(f"Warning: Mesh has no triangles: {mesh_path}")
                return None
            
            # Compute normals for proper rendering
            mesh.compute_vertex_normals()
            
            # Report color status
            if mesh.has_vertex_colors():
                print(f"Mesh has vertex colors")
            else:
                print(f"Warning: Mesh has no vertex colors")
            
            print(f"Loaded mesh: {mesh_filename} ({len(mesh.vertices)} vertices, {len(mesh.triangles)} triangles)")
            return mesh
            
        except Exception as e:
            print(f"Error loading mesh {mesh_path}: {e}")
            return None
    
    def _setup_ui(self):
        """Setup the user interface with dual panes and controls."""
        # Create main layout
        self.window.set_on_layout(self._on_layout)
        
        # Create widgets
        self._create_widgets()
        
        # Add widgets to window
        self.window.add_child(self.panel)
        self.window.add_child(self.scene_widget_left)
        self.window.add_child(self.scene_widget_right)
        
        # Setup scenes
        self._setup_scenes()
        
        # Load initial mesh
        self._update_mesh()
    
    def _create_widgets(self):
        """Create UI widgets."""
        em = self.window.theme.font_size
        
        # Control panel
        self.panel = gui.Vert(0.5 * em, gui.Margins(0.5 * em))
        
        # Title
        title = gui.Label("Mesh Viewer Controls")
        self.panel.add_child(title)
        
        # Method dropdown
        method_label = gui.Label("Meshing Method:")
        self.panel.add_child(method_label)
        
        self.method_dropdown = gui.Combobox()
        for method in self.methods:
            self.method_dropdown.add_item(method.upper())
        self.method_dropdown.selected_index = 0
        self.method_dropdown.set_on_selection_changed(self._on_method_changed)
        self.panel.add_child(self.method_dropdown)
        
        self.panel.add_fixed(0.5 * em)
        
        # Format dropdown
        format_label = gui.Label("Export Format:")
        self.panel.add_child(format_label)
        
        self.format_dropdown = gui.Combobox()
        for fmt in self.formats:
            self.format_dropdown.add_item(fmt.upper())
        self.format_dropdown.selected_index = 0
        self.format_dropdown.set_on_selection_changed(self._on_format_changed)
        self.panel.add_child(self.format_dropdown)
        
        self.panel.add_fixed(0.5 * em)
        
        # Info labels
        self.info_label = gui.Label("")
        self.panel.add_child(self.info_label)
        
        # Scene widgets (3D viewers)
        self.scene_widget_left = gui.SceneWidget()
        self.scene_widget_left.scene = rendering.Open3DScene(self.window.renderer)
        
        self.scene_widget_right = gui.SceneWidget()
        self.scene_widget_right.scene = rendering.Open3DScene(self.window.renderer)
    
    def _on_layout(self, layout_context):
        """Handle window layout."""
        r = self.window.content_rect
        panel_width = 250
        
        # Panel on the left
        self.panel.frame = gui.Rect(r.x, r.y, panel_width, r.height)
        
        # Calculate remaining width for scenes
        scene_x = r.x + panel_width
        scene_width = (r.width - panel_width) // 2
        
        # Left scene (point cloud)
        self.scene_widget_left.frame = gui.Rect(scene_x, r.y, scene_width, r.height)
        
        # Right scene (mesh)
        self.scene_widget_right.frame = gui.Rect(scene_x + scene_width, r.y, scene_width, r.height)
    
    def _setup_scenes(self):
        """Setup the 3D scenes for point cloud and mesh."""
        # Setup left scene (point cloud)
        self.scene_widget_left.scene.add_geometry("point_cloud", self.point_cloud, 
                                                   rendering.MaterialRecord())
        
        # Setup camera for left scene
        bounds = self.point_cloud.get_axis_aligned_bounding_box()
        self.scene_widget_left.setup_camera(60, bounds, bounds.get_center())
        
        # Add label for left scene
        self.scene_widget_left.scene.show_axes(True)
        
        # Setup right scene (will be populated with mesh)
        self.scene_widget_right.scene.show_axes(True)
    
    def _update_mesh(self):
        """Update the mesh display based on current selections."""
        # Load new mesh
        mesh = self._load_mesh(self.current_method, self.current_format)
        
        if mesh is None:
            self.info_label.text = f"âš  Mesh not found: {self.current_method}.{self.current_format}"
            # Clear right scene
            self.scene_widget_right.scene.clear_geometry()
            return
        
        self.current_mesh = mesh
        
        # Update info
        self.info_label.text = (f"Method: {self.current_method.upper()}\n"
                               f"Format: {self.current_format.upper()}\n"
                               f"Vertices: {len(mesh.vertices):,}\n"
                               f"Triangles: {len(mesh.triangles):,}")
        
        # Clear and update right scene
        self.scene_widget_right.scene.clear_geometry()
        self.scene_widget_right.scene.add_geometry("mesh", mesh, rendering.MaterialRecord())
        
        # Setup camera for right scene
        bounds = mesh.get_axis_aligned_bounding_box()
        self.scene_widget_right.setup_camera(60, bounds, bounds.get_center())
    
    def _on_method_changed(self, new_value, new_index):
        """Handle meshing method selection change."""
        self.current_method = self.methods[new_index]
        print(f"Method changed to: {self.current_method}")
        self._update_mesh()
    
    def _on_format_changed(self, new_value, new_index):
        """Handle format selection change."""
        self.current_format = self.formats[new_index]
        print(f"Format changed to: {self.current_format}")
        self._update_mesh()
    
    def run(self):
        """Run the application."""
        self.app.run()


def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description="Interactive dual-pane mesh viewer for point clouds and meshes"
    )
    
    parser.add_argument(
        "--input_file",
        type=str,
        default="../pclouds/chiller.ply",
        help="Path to input PLY point cloud file"
    )
    
    parser.add_argument(
        "--mesh_dir",
        type=str,
        default="../meshes",
        help="Directory containing generated mesh files"
    )
    
    args = parser.parse_args()
    
    # Check if input file exists
    if not Path(args.input_file).exists():
        print(f"Error: Input file not found: {args.input_file}")
        sys.exit(1)
    
    # Create and run viewer
    viewer = DualPaneMeshViewer(args.input_file, args.mesh_dir)
    viewer.run()


if __name__ == "__main__":
    main()
